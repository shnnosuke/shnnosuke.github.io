<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>

    <link rel="stylesheet" type="text/css" 
      href="/assets/css/straybirds.css" media="screen" />
    <link rel="stylesheet" type="text/css" 
      href="/assets/css/pygments.css" media="screen" />

    <!-- MathJax Section Start -->

    <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script>
        MathJax.Hub.Config({
              tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
              }
        });
        MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

    <!-- MathJax Section End -->

    <!-- Google Analytics Start-->
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48100787-1', 'shnnosuke.github.io');
  ga('send', 'pageview');

</script>

    <!-- Google Analytics End -->

    <title>web.py 源代码分析之 web.test.application.testRedirect</title>
  </head>

  <body>
    <div class="container">
      <header>
        <div class="container">
          <h1>
              <a href="/" title="Home Page"> 潇湘夜雨 </a>
          <span class="github-src">
            <a href ="https://github.com/shnnosuke/shnnosuke.github.io"
               target="_blank"
               title="Fork me on GitHub">
              <img src="/assets/images/GitHub-Mark-Light-32px.png" alt="">
            </a>
          </span>
          </h1>
        </div>
      </header>

      <aside id="left-side">
        <h2> 分类 </h2>
  <ul class="category-list">
      
            
                <li>
                <a href="/categories/操作系统"> 操作系统 (2) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/工具"> 工具 (4) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/技术"> 技术 (18) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/c语言"> c语言 (4) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/计算机系统"> 计算机系统 (3) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/思想"> 思想 (2) </a>
                </li>
            
      
            
                <li style="background-color: #444">
                <a href="/categories/源代码阅读"> 源代码阅读 (20) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/读书"> 读书 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/生活"> 生活 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/英语"> 英语 (10) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/科研"> 科研 (6) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/java"> java (11) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/虚拟机"> 虚拟机 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/设计模式"> 设计模式 (3) </a>
                </li>
            
      
  </ul>

      </aside>

      <aside id="right-side">
        <h2> 归档 </h2>
  <ul class="archive-list">
    
    
    
        
        
        
        
            
            <li>
                <a href="/2017/09">
                    2017-09 (1)
                </a>
            </li>

        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/08">
                    2014-08 (1)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/07">
                    2014-07 (5)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/05">
                    2014-05 (12)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/04">
                    2014-04 (3)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/03">
                    2014-03 (11)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/02">
                    2014-02 (6)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/01">
                    2014-01 (3)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2013/11">
                    2013-11 (10)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2013/10">
                    2013-10 (3)
                </a>
            </li>

        
        
    
        
        
        
        
            
            <li>
                <a href="/2010/09">
                    2010-09 (1)
                </a>
            </li>

        
        
    
  </ul>

      </aside>

      <article>

<h1>分模块测试</h1>

<h2>application.py</h2>

<p>对 application.py 的测试，调用命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">python test/application.py
</code></pre></div>
<h3>testRedirect</h3>
<div class="highlight"><pre><code class="language-python" data-lang="python">def testRedirect(self):
    urls = (
        &quot;/a&quot;, &quot;redirect /hello/&quot;,
        &quot;/b/(.*)&quot;, r&quot;redirect /hello/\1&quot;,
        &quot;/hello/(.*)&quot;, &quot;hello&quot;
    )
    app = web.application(urls, locals())
    class hello:
        def GET(self, name): 
            name = name or &#39;world&#39;
            return &quot;hello &quot; + name

    response = app.request(&#39;/a&#39;)
    self.assertEquals(response.status, &#39;301 Moved Permanently&#39;)
    self.assertEquals(
        response.headers[&#39;Location&#39;], 
        &#39;http://0.0.0.0:8080/hello/&#39;)

    response = app.request(&#39;/a?x=2&#39;)
    self.assertEquals(response.status, &#39;301 Moved Permanently&#39;)
    self.assertEquals(
        response.headers[&#39;Location&#39;], 
        &#39;http://0.0.0.0:8080/hello/?x=2&#39;)

    response = app.request(&#39;/b/foo?x=2&#39;)
    self.assertEquals(response.status, &#39;301 Moved Permanently&#39;)
    self.assertEquals(
        response.headers[&#39;Location&#39;], 
        &#39;http://0.0.0.0:8080/hello/foo?x=2&#39;)
</code></pre></div>
<p>看到这段代码首先对 <code>urls</code> 挺好奇的，<code>urls</code> 一般是一个 <code>url</code> 对应
一个处理它的类，可是 <code>redirect /hello/</code> 是什么意思？所以，我们
有必要看一下 <code>web.application</code> 如何对 <code>urls</code> 进行处理。</p>

<p>我们还从这句开始：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">response = app.request(&#39;/a&#39;)
</code></pre></div>
<p>看看 <code>urls</code> 是如何被处理的。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application.request

def request(self, localpart=&#39;/&#39;, method=&#39;GET&#39;, data=None,
            host=&quot;0.0.0.0:8080&quot;, headers=None, https=False, **kw):


    path, maybe_query = urllib.splitquery(localpart)
    query = maybe_query or &quot;&quot;

    ...

    env = dict(env, HTTP_HOST=host, REQUEST_METHOD=method, PATH_INFO=path, 
        QUERY_STRING=query, HTTPS=str(https))

    ...

    response.data = &quot;&quot;.join(self.wsgifunc()(env, start_response))

</code></pre></div>
<p>可以看出，请求的 <code>url</code> 被分成两部分： <code>path</code> 和 <code>maybe_query</code>, 
然后传入 <code>env</code>中。</p>

<p><code>urllib</code> 是标准库的一部分，但是在文档中没有对 <code>splitquery</code>
有说明，这可能是一个非公开的API。通过</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&gt;&gt;&gt; help(urllib.splitquery)
</code></pre></div>
<p>可以得到</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">splitquery(&#39;/path?query&#39;) --&gt; &#39;/path&#39;, &#39;query&#39;
</code></pre></div>
<p>看来这个调用是把 <code>url</code> 请求分成路径与请求两个部分，这也和
返回结果的赋值保持一致。</p>

<p>另外，最好不要使用这个函数，python 2.7 中提供了 <code>urlparse</code>
模块，可以完成同样功能（甚至更多），python 3 中这个模块
更改为 <code>urllib.parse</code>。</p>

<p>这里不再多说，只是明白这一句是要做什么就好。我们继续看数据
封装在 <code>env</code> 后发生的故事。</p>

<p>我们又来到这里：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">    response.data = &quot;&quot;.join(self.wsgifunc()(env, start_response))
</code></pre></div>
<p>最终对 <code>env</code> 的处理在 <code>wsgi</code> 函数中。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application.wsgifunc.wsgi

        def wsgi(env, start_resp):
            # clear threadlocal to avoid inteference of previous requests
            self._cleanup()

            self.load(env)
            try:
                # allow uppercase methods only
                if web.ctx.method.upper() != web.ctx.method:
                    raise web.nomethod()

                result = self.handle_with_processors()
                if is_generator(result):
                    result = peep(result)
                else:
                    result = [result]
            except web.HTTPError, e:
                result = [e.data]


            result = web.safestr(iter(result))

            status, headers = web.ctx.status, web.ctx.headers

            start_resp(status, headers)
</code></pre></div>
<p>同样，先把 <code>env</code> 载入 <code>web.ctx</code>， 然后我们通过 <code>print</code> 定位到
这一句改变了 <code>web.ctx.status</code> 的值。 </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">                result = self.handle_with_processors()
</code></pre></div>
<p>可见这里对 <code>url</code> 进行了分析。下面我们深入下去。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application.handle_with_processors

def handle_with_processors(self):
    def process(processors):
        try:
            if processors:
                p, processors = processors[0], processors[1:]
                return p(lambda: process(processors))
            else:
                return self.handle()
        except web.HTTPError:
            raise
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            print &gt;&gt; web.debug, traceback.format_exc()
            raise self.internalerror()

    # processors must be applied in the resvere order. (??)
    return process(self.processors)
</code></pre></div>
<p>这里 <code>processors</code> 为空，所以进入 <code>self.handle()</code></p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application.handle

def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)
</code></pre></div>
<p>这个 <code>self.mapping</code> 是将我们的 <code>urls</code> 转化成两两一组后的列表。
先看看 <code>_match</code>函数。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application._match

def _match(self, mapping, value):
    for pat, what in mapping:
        if isinstance(what, application):
            if value.startswith(pat):
                f = lambda: self._delegate_sub_application(pat, what)
                return f, None
            else:
                continue
        elif isinstance(what, basestring):
            what, result = utils.re_subm(&#39;^&#39; + pat + &#39;$&#39;, what, value)
        else:
            result = utils.re_compile(&#39;^&#39; + pat + &#39;$&#39;).match(value)

        if result: # it&#39;&#39;s a match
            return what, [x for x in result.groups()]
    return None, None
</code></pre></div>
<p>可以看出这是一个循环，根据当前的 <code>value</code> ，即 <code>web.ctx.path</code>
去查找 <code>urls</code> 中定义的对应项。what就是这个项。
先使用 <code>isinstance(what, application)</code> 看是不是使用了子程序。
再看看what是不是 <code>basestring</code> 的实例。直到运行至
result不为空，这说明找到了一个匹配。然后会返回匹配中
的所有分组。</p>

<p>当前的运行会选择第二个分支。
即：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application._match

elif isinstance(what, basestring):
    what, result = utils.re_subm(&#39;^&#39; + pat + &#39;$&#39;, what, value)
</code></pre></div>
<p><code>utils.re_subm</code> 对路径中的正则表达式进行处理。<code>pat</code> 和 <code>what</code>
是 <code>urls</code> 中对应的项， <code>value</code> 是当前的请求路径。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># utils.re_subm

def re_subm(pat, repl, string):
    &quot;&quot;&quot;
    Like re.sub, but returns the replacement _and_ the match object.

        &gt;&gt;&gt; t, m = re_subm(&#39;g(oo+)fball&#39;, r&#39;f\\1lish&#39;, &#39;goooooofball&#39;)
        &gt;&gt;&gt; t
        &#39;foooooolish&#39;
        &gt;&gt;&gt; m.groups()
        (&#39;oooooo&#39;,)
    &quot;&quot;&quot;
    compiled_pat = re_compile(pat)
    proxy = _re_subm_proxy()
    compiled_pat.sub(proxy.__call__, string)
    return compiled_pat.sub(repl, string), proxy.match

</code></pre></div>
<p>这里 <code>re_compile(pat)</code> 的含义与 <code>re.complie(pat)</code> 类似，
返回一个<code>RegexObject</code> 对象，只不过加入了 <code>Cache</code> 机制，避免多次执行 <code>re.complie</code> 调用。</p>

<p>下面看这两行代码</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">proxy = _re_subm_proxy()
compiled_pat.sub(proxy.__call__, string)
</code></pre></div>
<p>其中 <code>_re_subm_proxy</code> 定义为：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">class _re_subm_proxy:
    def __init__(self): 
        self.match = None
    def __call__(self, match): 
        self.match = match
        return &#39;&#39;
</code></pre></div>
<p><code>compiled_pat</code> 会与 <code>string</code> 一起生成一个 <code>Match</code> 对象，
这个对象会存储在一个 <code>_re_subm_proxy</code> 对象，即 <code>proxy</code>中
我们可以看到 <code>return</code> 中，<code>proxy</code> 最后会将其 <code>match</code> 返回。
我在想，为什么使用<code>search</code>直接生成一个 <code>Match</code>  对象然后返回呢？
查了一下，这似乎与 <code>代理模式</code> 相关。但具体为什么还不知道。又查了很久，似乎又与 <code>弱引用</code>, 和之前的 Cache 相关,
但是不确定。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">问题：为什么要使用代理类
</code></pre></div>
<p>最后的 <code>return</code> 语句返回两个值，其中
<code>compiled_pat.sub (repl, string)</code> 是把 <code>string</code> 与 <code>pat</code>
中匹配的部分，用于替换 <code>repl</code> 中对应的组号。<code>proxy.match</code> 就是 <code>pat</code> 和 <code>string</code> 匹配得到的　<code>Mathc</code>对象。</p>

<p>关于 <code>Python 正则表达式</code> 可以参考这篇：
<a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html">Python 正则表达式指南</a></p>

<p>到这里，我们可能就明白了一开始的时候的那段：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application._match

elif isinstance(what, basestring):
    what, result = utils.re_subm(&#39;^&#39; + pat + &#39;$&#39;, what, value)
</code></pre></div>
<p>的含义，它的意思是如何 <code>urls</code> 里有一对 <code>(url,class)</code>
其中 <code>url</code> 和　<code>class</code> 都是用正则表达式表示的，
这时候实际来了一个请求 <code>r_url</code>，它会与 <code>url</code>进行
匹配，根据这个匹配生成相应的 <code>r_class</code>。</p>

<p>看看刚才的示例就明白了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&gt;&gt;&gt; t, m = re_subm(&#39;g(oo+)fball&#39;, r&#39;f\\1lish&#39;, &#39;goooooofball&#39;)
&gt;&gt;&gt; t
&#39;foooooolish&#39;
</code></pre></div>
<p>你可以把 <code>re_subm</code> 的三个参数依序当成 <code>url</code>, <code>class</code>，
以及 <code>r_url</code>，最后得到的 <code>t</code> 就是 <code>r_class</code>。</p>

<p>举个例子，假如有一系列页面，分别是 <code>req1</code>, <code>req2</code>, 
<code>req3</code>, ... , <code>reqN</code>, 需要处理。</p>

<p>那么就可以在 <code>urls</code> 里加入</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(r&#39;req(\d+)&#39;, r&#39;proc\1&#39;)
</code></pre></div>
<p>这样，如果来了请求　<code>req2</code>，通过<code>re_subm</code>自然会解析成 <code>proc2</code>。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&gt;&gt;&gt; t, m = re_subm(r&#39;req(\d+)&#39;, r&#39;proc\1&#39;, &#39;req2&#39;)
&gt;&gt;&gt; t
&#39;proc2&#39;
&gt;&gt;&gt; m.group(0)
&#39;req2&#39;
&gt;&gt;&gt; m.group(1)
&#39;2&#39;
</code></pre></div>
<p>总之，</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)
</code></pre></div>
<p><code>self._match</code> 返回的是请求 <code>request(&#39;/a&#39;)</code> 与</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">python
        urls = (
            &quot;/a&quot;, &quot;redirect /hello/&quot;,
            &quot;/b/(.*)&quot;, r&quot;redirect /hello/\1&quot;,
            &quot;/hello/(.*)&quot;, &quot;hello&quot;
        )
</code></pre></div>
<p>进行匹配后的结果， <code>&#39;/a&#39;</code> 自然与 <code>urls[0]</code>
匹配，得到的 <code>fn</code> 是 <code>&quot;redirect /hello/&quot;</code>,
得到的 <code>args</code> 是 <code>[]</code>，因为<code>urls[0]</code>里面就没分组。</p>

<p>好了，现在进入 <code>self._delegate</code>，看看解析后的
<code>fn</code> 和　<code>args</code> 被如何处理。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">def _delegate(self, f, fvars, args=[]):
    def handle_class(cls):
        meth = web.ctx.method
        if meth == &#39;HEAD&#39; and not hasattr(cls, meth):
            meth = &#39;GET&#39;
        if not hasattr(cls, meth):
            raise web.nomethod(cls)
        tocall = getattr(cls(), meth)
        return tocall(\*args)

    def is_class(o): return isinstance(o, (types.ClassType, type))

    if f is None:
        raise web.notfound()
    elif isinstance(f, application):
        return f.handle_with_processors()
    elif is_class(f):
        return handle_class(f)
    elif isinstance(f, basestring):
        if f.startswith(&#39;redirect &#39;):
            url = f.split(&#39; &#39;, 1)[1]
            if web.ctx.method == &quot;GET&quot;:
                x = web.ctx.env.get(&#39;QUERY_STRING&#39;, &#39;&#39;)
                if x:
                    url += &#39;?&#39; + x
            raise web.redirect(url)
        elif &#39;.&#39; in f:
            mod, cls = f.rsplit(&#39;.&#39;, 1)
            mod = __import__(mod, None, None, [&#39;&#39;])
            cls = getattr(mod, cls)
        else:
            cls = fvars[f]
        return handle_class(cls)
    elif hasattr(f, &#39;__call__&#39;):
        return f()
    else:
        return web.notfound()
</code></pre></div>
<p>一眼就可以看出有一个 <code>elif</code> 分支对 <code>redirect</code> 进行了处理。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">elif isinstance(f, basestring):
    if f.startswith(&#39;redirect &#39;):
        url = f.split(&#39; &#39;, 1)[1]
        if web.ctx.method == &quot;GET&quot;:
            x = web.ctx.env.get(&#39;QUERY_STRING&#39;, &#39;&#39;)
            if x:
                url += &#39;?&#39; + x
        raise web.redirect(url)
</code></pre></div>
<p>分析出 <code>redirect /hello/</code> 中的 <code>/hello/</code>，再看看
有没有查询字串，就是请求里有没有<code>?xx</code> 什么的。
得到最终的 <code>url</code> ，转给 <code>redirect</code> 函数处理。
直接找到 <code>webapi.py</code>，看到 <code>redirect</code> 的定义。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">class Redirect(HTTPError):
    &quot;&quot;&quot;A `301 Moved Permanently` redirect.&quot;&quot;&quot;
    def __init__(self, url, status=&#39;301 Moved Permanently&#39;, absolute=False):
        &quot;&quot;&quot;
        Returns a `status` redirect to the new URL. 
        `url` is joined with the base URL so that things like 
        `redirect(&quot;about&quot;) will work properly.
        &quot;&quot;&quot;
        newloc = urlparse.urljoin(ctx.path, url)

        if newloc.startswith(&#39;/&#39;):
            if absolute:
                home = ctx.realhome
            else:
                home = ctx.home
            newloc = home + newloc

        headers = {
            &#39;Content-Type&#39;: &#39;text/html&#39;,
            &#39;Location&#39;: newloc
        }
        HTTPError.__init__(self, status, headers, &quot;&quot;)

redirect = Redirect
</code></pre></div>
<p>这时候传过来的 <code>url</code> 是 <code>/hello/</code>。 注意 <code>status</code>
的默认值。
先使用 <code>urljoin</code> 得到一个绝对路径。官网上给出的
<code>urlparse.urljoin</code> 的例子是：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; from urlparse import urljoin
&gt;&gt;&gt; urljoin(&#39;http://www.cwi.nl/%7Eguido/Python.html&#39;, &#39;FAQ.html&#39;)
&#39;http://www.cwi.nl/%7Eguido/FAQ.html&#39;
</code></pre></div>
<p>另外一个例子是针对第二个参数是绝对路径的情况的。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; urljoin(&#39;http://www.cwi.nl/%7Eguido/Python.html&#39;,
...         &#39;//www.python.org/%7Eguido&#39;)
&#39;http://www.python.org/%7Eguido&#39;
</code></pre></div>
<p>第二个例子的用法和我们当前的状况一致。所以得到的
<code>newloc</code> 还是 <code>/hello/</code>。</p>

<p>然后再查看 <code>ctx.home</code> 和 <code>ctx.realhome</code> 得到
新的　<code>newloc</code>。</p>

<p>在 <code>application.py</code> 中， <code>load</code> 函数定义了一些 <code>path</code>:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">ctx.homedomain = ctx.protocol + &#39;://&#39; + env.get(&#39;HTTP_HOST&#39;, &#39;[unknown]&#39;)
ctx.homepath = os.environ.get(&#39;REAL_SCRIPT_NAME&#39;, env.get(&#39;SCRIPT_NAME&#39;, &#39;&#39;))
ctx.home = ctx.homedomain + ctx.homepath
#@@ home is changed when the request is handled to a sub-application.
#@@ but the real home is required for doing absolute redirects.
ctx.realhome = ctx.home
</code></pre></div>
<p>从这可以看出，如果调用子程序　<code>ctx.home</code> 会改变，
但是　<code>ctx.realhome</code> 不会变，它用来在 redirect 时
生成绝对路径。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">if newloc.startswith(&#39;/&#39;):
    if absolute:
        home = ctx.realhome
    else:
        home = ctx.home
    newloc = home + newloc
</code></pre></div>
<p>现在可以理解了，如果 <code>absolute</code> 为真，那就用
<code>ctx.realhome</code> 和 <code>newloc</code> 组成新值，
如果不为真，直接用 <code>ctx.home</code>。这可能在使用子程序，
可以转向到以子程序为基础的<code>url</code> 中。</p>

<p>现在回到 <code>Redirect</code>。转到 <code>HTTPError</code>。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">class HTTPError(Exception):
    def __init__(self, status, headers={}, data=&quot;&quot;):
        ctx.status = status
        for k, v in headers.items():
            header(k, v)
        self.data = data
        Exception.__init__(self, status)
</code></pre></div>
<p><code>ctx.status</code> 被设置，调用 <code>Exception</code>。</p>

<p>之后我们回到　<code>web.redirect(status)</code> 调用处。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">def _delegate(self, f, fvars, args=[]):

    ...

    elif isinstance(f, basestring):
        if f.startswith(&#39;redirect &#39;):
            url = f.split(&#39; &#39;, 1)[1]
            if web.ctx.method == &quot;GET&quot;:
                x = web.ctx.env.get(&#39;QUERY_STRING&#39;, &#39;&#39;)
                if x:
                    url += &#39;?&#39; + x
            raise web.redirect(url)


    ...

</code></pre></div>
<p>可以看出，这里把异常抛出。所以我们回到上一层，看看
相应的处理。</p>

<p>上一层：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)
</code></pre></div>
<p>再上一层：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application.handle_with_processors

def handle_with_processors(self):
    def process(processors):
        try:
            if processors:
                p, processors = processors[0], processors[1:]
                return p(lambda: process(processors))
            else:
                return self.handle()
        except web.HTTPError:
            raise
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            print &gt;&gt; web.debug, traceback.format_exc()
            raise self.internalerror()

    # processors must be applied in the resvere order. (??)
    return process(self.processors)
</code></pre></div>
<p>再上一层：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"># web.application.wsgifunc.wsgi

        def wsgi(env, start_resp):
            # clear threadlocal to avoid inteference of previous requests
            self._cleanup()

            self.load(env)
            try:
                # allow uppercase methods only
                if web.ctx.method.upper() != web.ctx.method:
                    raise web.nomethod()

                result = self.handle_with_processors()
                if is_generator(result):
                    result = peep(result)
                else:
                    result = [result]
            except web.HTTPError, e:
                result = [e.data]


            result = web.safestr(iter(result))

            status, headers = web.ctx.status, web.ctx.headers

            start_resp(status, headers)
</code></pre></div>
<p>这里终于看到了对异常的处理。这里 <code>e.data</code> 为空。我
们之前并没有设置这个值。</p>

<p>接着看后续处理, <code>safestr</code> 在 <code>utils.py</code> 中定义，
它负责把给定的对象转化成 <code>utf-8</code> 编码的字符串。
下一句设置 <code>status</code> 和 <code>headers</code> 的值。之前</p>

<p>我们已经看到 <code>web.ctx.status</code> 被设置了:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">class HTTPError(Exception):
    def __init__(self, status, headers={}, data=&quot;&quot;):
        ctx.status = status
        for k, v in headers.items():
            header(k, v)
        self.data = data
        Exception.__init__(self, status)
</code></pre></div>
<p><code>__init__</code> 中的 <code>status</code> 参数在上一层中设置。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">class Redirect(HTTPError):
    &quot;&quot;&quot;A `301 Moved Permanently` redirect.&quot;&quot;&quot;
    def __init__(self, url, status=&#39;301 Moved Permanently&#39;, absolute=False):
        &quot;&quot;&quot;
        Returns a `status` redirect to the new URL. 
        `url` is joined with the base URL so that things like 
        `redirect(&quot;about&quot;) will work properly.
        &quot;&quot;&quot;
        newloc = urlparse.urljoin(ctx.path, url)

        if newloc.startswith(&#39;/&#39;):
            if absolute:
                home = ctx.realhome
            else:
                home = ctx.home
            newloc = home + newloc

        headers = {
            &#39;Content-Type&#39;: &#39;text/html&#39;,
            &#39;Location&#39;: newloc
        }
        HTTPError.__init__(self, status, headers, &quot;&quot;)

redirect = Redirect
</code></pre></div>
<p>注意这里的　<code>status</code> 默认参数。</p>

<p>现在再回到 </p>
<div class="highlight"><pre><code class="language-python" data-lang="python">def wsgi(env, start_resp):
    # clear threadlocal to avoid inteference of previous requests
    self._cleanup()

    self.load(env)

    try:
        # allow uppercase methods only
        if web.ctx.method.upper() != web.ctx.method:
            raise web.nomethod()


        result = self.handle_with_processors()

        if is_generator(result):
            result = peep(result)
        else:
            result = [result]
    except web.HTTPError, e:
        result = [e.data]


    result = web.safestr(iter(result))

    status, headers = web.ctx.status, web.ctx.headers

    start_resp(status, headers)

    def cleanup():
        self._cleanup()
        yield &#39;&#39; # force this function to be a generator

    return itertools.chain(result, cleanup())
</code></pre></div>
<p>随后调用　<code>start_resp</code> ，对 <code>status</code>, <code>headers</code>
进行处理。我们再回到上一层。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">#web.application.request

def request(self, localpart=&#39;/&#39;, method=&#39;GET&#39;, data=None,
                host=&quot;0.0.0.0:8080&quot;, headers=None, https=False, **kw):

        ...

        response = web.storage()
        def start_response(status, headers):
            response.status = status
            response.headers = dict(headers)
            response.header_items = headers
        response.data = &quot;&quot;.join(self.wsgifunc()(env, start_response))
        return response
</code></pre></div>
<p>这时候，<code>response</code> 中的 <code>stauts</code>　会设置好。
最后，返回最初的调用。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">def testRedirect(self):
    urls = (
        &quot;/a&quot;, &quot;redirect /hello/&quot;,
        &quot;/b/(.*)&quot;, r&quot;redirect /hello/\1&quot;,
        &quot;/hello/(.*)&quot;, &quot;hello&quot;
    )
    app = web.application(urls, locals())
    class hello:
        def GET(self, name): 
            name = name or &#39;world&#39;
            return &quot;hello &quot; + name

    response = app.request(&#39;/a&#39;)
    self.assertEquals(response.status, &#39;301 Moved Permanently&#39;)
    self.assertEquals(response.headers[&#39;Location&#39;], &#39;http://0.0.0.0:8080/hello/&#39;)
</code></pre></div>
<p><code>self.assertEquals</code> 会验证 <code>response.status</code> 的值。</p>

<p>所以，到这里，<code>testRedirect</code> 函数就分析结束了。</p>


      </article>

      <div class="comments">
        
          <div id="disqus_thread"></div>
 <script type="text/javascript">
     /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
     var disqus_shortname = 'shnnosuke'; // required: replace example with your forum shortname

     /* * * DON'T EDIT BELOW THIS LINE * * */
     (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
 </script>
 <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

        
      </div>


      <footer>
        Copyright (c) shnnosuke 2014
      </footer>

    </div>
  </body>
</html>
