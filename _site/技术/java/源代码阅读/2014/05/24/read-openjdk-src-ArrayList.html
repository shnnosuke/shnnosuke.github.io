<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>

    <link rel="stylesheet" type="text/css" 
      href="/assets/css/straybirds.css" media="screen" />
    <link rel="stylesheet" type="text/css" 
      href="/assets/css/pygments.css" media="screen" />

    <!-- MathJax Section Start -->

    <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script>
        MathJax.Hub.Config({
              tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
              }
        });
        MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

    <!-- MathJax Section End -->

    <!-- Google Analytics Start-->
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48100787-1', 'shnnosuke.github.io');
  ga('send', 'pageview');

</script>

    <!-- Google Analytics End -->

    <title>OpenJDK 源码阅读之 ArrayList</title>
  </head>

  <body>
    <div class="container">
      <header>
        <div class="container">
          <h1>
              <a href="/" title="Home Page"> 潇湘夜雨 </a>
          <span class="github-src">
            <a href ="https://github.com/shnnosuke/shnnosuke.github.io"
               target="_blank"
               title="Fork me on GitHub">
              <img src="/assets/images/GitHub-Mark-Light-32px.png" alt="">
            </a>
          </span>
          </h1>
        </div>
      </header>

      <aside id="left-side">
        <h2> 分类 </h2>
  <ul class="category-list">
      
            
                <li>
                <a href="/categories/操作系统"> 操作系统 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/工具"> 工具 (4) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/技术"> 技术 (19) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/c语言"> c语言 (4) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/计算机系统"> 计算机系统 (3) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/思想"> 思想 (2) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/源代码阅读"> 源代码阅读 (20) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/读书"> 读书 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/生活"> 生活 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/英语"> 英语 (10) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/科研"> 科研 (6) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/java"> java (11) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/虚拟机"> 虚拟机 (1) </a>
                </li>
            
      
            
                <li>
                <a href="/categories/设计模式"> 设计模式 (3) </a>
                </li>
            
      
  </ul>

      </aside>

      <aside id="right-side">
        <h2> 归档 </h2>
  <ul class="archive-list">
    
    
    
        
        
        
        
            
            <li>
                <a href="/2017/09">
                    2017-09 (1)
                </a>
            </li>

        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/08">
                    2014-08 (1)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/07">
                    2014-07 (5)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/05">
                    2014-05 (12)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/04">
                    2014-04 (3)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/03">
                    2014-03 (11)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/02">
                    2014-02 (6)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2014/01">
                    2014-01 (3)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2013/11">
                    2013-11 (10)
                </a>
            </li>

        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
            
            <li>
                <a href="/2013/10">
                    2013-10 (3)
                </a>
            </li>

        
        
    
        
        
        
        
            
            <li>
                <a href="/2010/09">
                    2010-09 (1)
                </a>
            </li>

        
        
    
  </ul>

      </aside>

      <article>

<h1>OpenJDK 源码阅读之 ArrayList</h1>

<hr>

<h2>概要</h2>

<ul>
<li>类继承关系 </li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">java.lang.Object
    java.util.AbstractCollection&lt;E&gt;
        java.util.AbstractList&lt;E&gt;
            java.util.ArrayList&lt;E&gt;
</code></pre></div>
<ul>
<li>定义</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
}
</code></pre></div>
<h2>实现</h2>

<ul>
<li>transient</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"> private transient Object[] elementData;
</code></pre></div>
<p>声明为 <code>transient</code>后，这个字段不会被序列化。</p>

<ul>
<li>toArray</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">    /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection&#39;s
     * iterator.
     *
     * @param c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public ArrayList(Collection&lt;? extends E&gt; c) {
        elementData = c.toArray();
        size = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    }
</code></pre></div>
<p>注意对 <code>elementData</code> 的检查，<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652">Bug 6260652</a>中对此有详细描述。主要原因是 <code>c.toArray()</code> 不一定会返回　<code>Object[]</code> 类型的值。</p>

<ul>
<li>SuppressWarnings</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"> @SuppressWarnings(&quot;unchecked&quot;)
                ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();
</code></pre></div>
<p>告诉编译器，对特定类型的 <code>warning</code> 保持静默。</p>

<ul>
<li>参数检查</li>
</ul>

<p>可以看出标准库中的程序，在很多地方都需要对参数进行检查，以保证程序的健壮性。</p>

<p>检查 <code>null</code></p>
<div class="highlight"><pre><code class="language-java" data-lang="java">public int indexOf(Object o) {
    if (o == null) {
    } else {
    }
    return -1;
</code></pre></div>
<p>检查参数上界，下界</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"> private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
</code></pre></div>
<ul>
<li>ArrayList 的 index 检查</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"> @SuppressWarnings(&quot;unchecked&quot;)
    E elementData(int index) {
        return (E) elementData[index];
    }
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"> public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java">private void rangeCheck(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
</code></pre></div>
<p>注意　<code>rangeCheck</code> 只检查了上界，但是如果将　<code>index</code> 设置成负数，也会抛出异常，异常是在 <code>elementData[index]</code> 中抛出的，猜想是在数组的实现中，对负数进行检查，因为任何一个数组，<code>index</code> 都不可能为负数，但是在实现数组时，不知道数组的元素个数，所以上界检查在此时发生。</p>

<ul>
<li>元素访问</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"> @SuppressWarnings(&quot;unchecked&quot;)
    E elementData(int index) {
        return (E) elementData[index];
    }
</code></pre></div>
<p>专门写了一个函数用来访问元素，而不是直接使用 <code>elementData[index]</code>，只因为需要向上转型么？还是 <code>SuppressWarning</code>　会重复。</p>

<ul>
<li>private</li>
</ul>

<p>对于仅仅在类内部使用的函数，要声明为 <code>private</code>。</p>

<ul>
<li>add 参数检查</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">   public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java">   private void rangeCheckForAdd(int index) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
</code></pre></div>
<p>可以看出这里对　<code>index</code> 的上界和下界都检查了，虽然　<code>add</code> 的<code>7</code> 行会进行检查，但在 <code>add</code>　的 <code>4</code>, <code>5</code> 行中就已经可能出错。</p>

<ul>
<li>强制垃圾回收</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // Let gc do its work

        return oldValue;
    }
</code></pre></div>
<p>注意第 <code>11</code>行把最后一个元素设置为<code>null</code>，这可以使得<code>gc</code>工作。好奇如何用实验验证这一点。</p>

<ul>
<li>remove(Object o)</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
</code></pre></div>
<p>整个框架与 <code>indexOf</code> 函数是相似的，注意那个 <code>fastRemove</code> 函数，它与 <code>remove(index)</code> 的不同在于它：</p>

<ol>
<li>是 <code>private</code></li>
<li>无参数检查，因为传给它的参数一定是合法的</li>
<li>不返回值</li>
</ol>

<p>由此细节可见，标准库中函数的精益求精。(不知道是不是我过度揣测了，有经过性能测试么？)</p>

<ul>
<li>batchRemove</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">   private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r &lt; size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            if (w != size) {
                for (int i = w; i &lt; size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }
</code></pre></div>
<p>注意 <code>finally</code> 里的代码，这段代码保证，即使 <code>try</code> 中的代码出了问题，也会最大程度上保证数据的一致性。如果 <code>r</code> 没有遍历完，那么后面没有检查过的数据都要保留下来。</p>

<ul>
<li>线程安全</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out array length
        s.writeInt(elementData.length);

        // Write out all elements in the proper order.
        for (int i=0; i&lt;size; i++)
            s.writeObject(elementData[i]);

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

    }
</code></pre></div>
<p>注意那个　<code>modCount</code> 的检查，这是为了确定在 <code>5-12</code>　行代码执行过程中，<code>List</code> 没有改变。改变的原因可能是由于多线程并发执行，在这期间另一个线程执行，改变了 <code>List</code> 的状态。</p>

<ul>
<li>容量扩充</li>
</ul>

<p>容量扩充会在任何可能引起　<code>ArrayList</code> 大小改变的情况下发生，如何扩充呢，代码在 <code>grow</code> 函数中。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">   private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
</code></pre></div>
<p>可以看出，<code>oldCapacity</code> 新增的容量是它的一半。另外，还有一个 <code>hugeCapacity</code>，如果需要扩充的容量比　<code>MAX_ARRAY_SIZE</code> 还大，会调用这个函数，重新调整大小。但再大也大不过　<code>Integer.MAX_VALUE</code>。</p>

<ul>
<li>元素位置调整</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }

        public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // Let gc do its work

        return oldValue;
    }
</code></pre></div>
<p>无论是增加元素还是删除元素，都可能使得很多元素的位置发生改变，这里就是用 <code>System.arraycopy</code> 来把大量元素放在其它位置，如果元素很多，经常需要调整，是很浪费时间的。</p>


      </article>

      <div class="comments">
        
          <div id="disqus_thread"></div>
 <script type="text/javascript">
     /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
     var disqus_shortname = 'shnnosuke'; // required: replace example with your forum shortname

     /* * * DON'T EDIT BELOW THIS LINE * * */
     (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
 </script>
 <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

        
      </div>


      <footer>
        Copyright (c) shnnosuke 2014
      </footer>

    </div>
  </body>
</html>
